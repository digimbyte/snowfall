#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using YamlDotNet.RepresentationModel;

namespace Core.Localisation.Editor
{
    public static class LocalisationCodegen
    {
        private const string Folder = "Assets/Core/Data/localisation";
        private const string LangPrefix = "lang_";

        private const string OutputLangs = "Assets/Core/Data/localisation/langs.generated.cs";
        private const string OutputDefs  = "Assets/Core/Data/localisation/defs.generated.cs";

        [MenuItem("Core/Localisation/Regenerate defs + langs")]
        public static void RegenerateAll()
        {
            var langAssets = FindLangYamlAssets();
            GenerateLangs(langAssets);
            GenerateDefs(langAssets);

            AssetDatabase.ImportAsset(OutputLangs);
            AssetDatabase.ImportAsset(OutputDefs);
            AssetDatabase.Refresh();
        }

        private static List<(string id, string assetPath)> FindLangYamlAssets()
        {
            var result = new List<(string id, string assetPath)>();
            var guids = AssetDatabase.FindAssets("t:TextAsset", new[] { Folder });

            foreach (var guid in guids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                var file = Path.GetFileName(path);
                if (file == null) continue;

                if (!file.StartsWith(LangPrefix, StringComparison.OrdinalIgnoreCase))
                    continue;

                if (!file.EndsWith(".yaml", StringComparison.OrdinalIgnoreCase) &&
                    !file.EndsWith(".yml", StringComparison.OrdinalIgnoreCase))
                    continue;

                var id = Path.GetFileNameWithoutExtension(file).Substring(LangPrefix.Length);
                if (string.IsNullOrWhiteSpace(id))
                    continue;

                result.Add((id.Trim(), path));
            }

            result.Sort((a, b) => string.Compare(a.id, b.id, StringComparison.OrdinalIgnoreCase));
            return result;
        }

        private static void GenerateLangs(List<(string id, string assetPath)> langs)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// AUTO-GENERATED BY LocalisationCodegen - DO NOT EDIT BY HAND");
            sb.AppendLine($"// Generated at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();
            sb.AppendLine("namespace Core.Localisation");
            sb.AppendLine("{");
            sb.AppendLine("    public static class langs");
            sb.AppendLine("    {");

            if (langs.Count == 0)
            {
                sb.AppendLine("        // No lang_<id>.yaml files found under Assets/Core/Data/localisation");
            }
            else
            {
                foreach (var (id, _) in langs)
                {
                    var ident = MakeIdentifier(id);
                    sb.AppendLine($"        public static readonly LocalLanguage {ident} = new LocalLanguage(\"{id}\");");
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            File.WriteAllText(OutputLangs, sb.ToString(), Encoding.UTF8);
        }

        private static void GenerateDefs(List<(string id, string assetPath)> langs)
        {
            // Choose a canonical language file for structure.
            string canonicalPath = langs.FirstOrDefault(l => string.Equals(l.id, "en", StringComparison.OrdinalIgnoreCase)).assetPath;
            if (string.IsNullOrEmpty(canonicalPath) && langs.Count > 0)
            {
                canonicalPath = langs[0].assetPath;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// AUTO-GENERATED BY LocalisationCodegen - DO NOT EDIT BY HAND");
            sb.AppendLine($"// Generated at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            if (!string.IsNullOrEmpty(canonicalPath))
                sb.AppendLine($"// Structure source: {canonicalPath}");
            sb.AppendLine();
            sb.AppendLine("namespace Core.Localisation");
            sb.AppendLine("{");
            sb.AppendLine("    public static class defs");
            sb.AppendLine("    {");

            if (string.IsNullOrEmpty(canonicalPath))
            {
                sb.AppendLine("        // No canonical lang_<id>.yaml found. Create at least one file (e.g. lang_en.yaml) and regenerate.");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                File.WriteAllText(OutputDefs, sb.ToString(), Encoding.UTF8);
                return;
            }

            var yamlAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(canonicalPath);
            if (yamlAsset == null)
            {
                sb.AppendLine("        // Failed to load canonical YAML as TextAsset.");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                File.WriteAllText(OutputDefs, sb.ToString(), Encoding.UTF8);
                return;
            }

            var stream = new YamlStream();
            using (var reader = new StringReader(yamlAsset.text))
            {
                stream.Load(reader);
            }

            if (stream.Documents.Count == 0)
            {
                sb.AppendLine("        // Canonical YAML is empty.");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                File.WriteAllText(OutputDefs, sb.ToString(), Encoding.UTF8);
                return;
            }

            var root = stream.Documents[0].RootNode;
            if (root is not YamlMappingNode rootMap)
            {
                sb.AppendLine("        // Canonical YAML root must be a mapping.");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                File.WriteAllText(OutputDefs, sb.ToString(), Encoding.UTF8);
                return;
            }

            foreach (var kv in rootMap.Children)
            {
                if (kv.Key is not YamlScalarNode keyScalar) continue;
                var seg = NormalizeSegmentForPath(keyScalar.Value);
                if (string.IsNullOrEmpty(seg)) continue;

                EmitNode(sb, seg, kv.Value, new List<string> { seg }, indentLevel: 2);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            File.WriteAllText(OutputDefs, sb.ToString(), Encoding.UTF8);
        }

        private static void EmitNode(StringBuilder sb, string segment, YamlNode node, List<string> path, int indentLevel)
        {
            string indent = new string(' ', indentLevel * 4);
            string className = MakeIdentifier(segment);

            // Always emit a class for nodes that have children (mapping/sequence).
            if (node is YamlMappingNode map)
            {
                sb.AppendLine($"{indent}public static class {className}");
                sb.AppendLine($"{indent}{{");

                // Node self text ($)
                var selfKey = new YamlScalarNode(YamlLocalisationTable.SelfTextKey);
                if (map.Children.TryGetValue(selfKey, out var selfNode) && selfNode is YamlScalarNode)
                {
                    string selfPath = string.Join(".", path);
                    sb.AppendLine($"{indent}    public static readonly LocalKey self = new LocalKey(\"{selfPath}\");");
                }

                // Children
                foreach (var kv in map.Children)
                {
                    if (kv.Key is not YamlScalarNode keyScalar) continue;
                    var raw = keyScalar.Value ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(raw)) continue;
                    if (string.Equals(raw.Trim(), YamlLocalisationTable.SelfTextKey, StringComparison.Ordinal))
                        continue;

                    // If someone used dotted keys, split into multiple segments for structure.
                    var segments = raw.Split(new[] { '.' }, StringSplitOptions.RemoveEmptyEntries)
                                     .Select(NormalizeSegmentForPath)
                                     .Where(s => !string.IsNullOrEmpty(s))
                                     .ToArray();

                    EmitChild(sb, segments, kv.Value, path, indentLevel + 1);
                }

                sb.AppendLine($"{indent}}}");
                return;
            }

            if (node is YamlSequenceNode seq)
            {
                sb.AppendLine($"{indent}public static class {className}");
                sb.AppendLine($"{indent}{{");

                for (int i = 0; i < seq.Children.Count; i++)
                {
                    var childSeg = i.ToString();
                    EmitChild(sb, new[] { childSeg }, seq.Children[i], path, indentLevel + 1);
                }

                sb.AppendLine($"{indent}}}");
                return;
            }

            // Scalar leaf at root: emit as key (rare but supported)
            string leafPath = string.Join(".", path);
            sb.AppendLine($"{indent}public static readonly LocalKey {className} = new LocalKey(\"{leafPath}\");");
        }

        private static void EmitChild(StringBuilder sb, string[] segments, YamlNode valueNode, List<string> parentPath, int indentLevel)
        {
            // Walk/emit intermediate nodes if dotted key produced multiple segments.
            if (segments == null || segments.Length == 0)
                return;

            if (segments.Length == 1)
            {
                var seg = NormalizeSegmentForPath(segments[0]);
                var nextPath = new List<string>(parentPath) { seg };

                if (valueNode is YamlScalarNode)
                {
                    string indent = new string(' ', indentLevel * 4);
                    string fieldName = MakeIdentifier(seg);
                    string fullPath = string.Join(".", nextPath);
                    sb.AppendLine($"{indent}public static readonly LocalKey {fieldName} = new LocalKey(\"{fullPath}\");");
                }
                else
                {
                    EmitNode(sb, seg, valueNode, nextPath, indentLevel);
                }

                return;
            }

            // Multiple segments: nest classes to preserve IDE tree.
            var head = NormalizeSegmentForPath(segments[0]);
            var tail = segments.Skip(1).Select(NormalizeSegmentForPath).Where(s => !string.IsNullOrEmpty(s)).ToArray();
            var headPath = new List<string>(parentPath) { head };

            // Create a synthetic nested mapping wrapper so EmitNode can emit the full nested structure.
            YamlNode wrapped = valueNode;
            for (int i = tail.Length - 1; i >= 0; i--)
            {
                var m = new YamlMappingNode();
                m.Add(new YamlScalarNode(tail[i]), wrapped);
                wrapped = m;
            }

            EmitNode(sb, head, wrapped, headPath, indentLevel);
        }

        private static string MakeIdentifier(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw))
                return "_";

            raw = NormalizeSegmentForPath(raw);

            // numeric-only -> prefix underscore
            if (raw.All(char.IsDigit))
                raw = "_" + raw;

            var chars = raw.Select(c => char.IsLetterOrDigit(c) || c == '_' ? c : '_').ToArray();
            if (chars.Length == 0)
                return "_";

            if (char.IsDigit(chars[0]))
                return "_" + new string(chars);

            return new string(chars);
        }

        private static string NormalizeSegmentForPath(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw))
                return string.Empty;

            // Keep path segments stable and predictable.
            return raw.Trim().Replace(' ', '_');
        }
    }
}
#endif
